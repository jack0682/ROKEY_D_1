#!/usr/bin/env python3
import math
import rclpy
import random
import json
import time
import threading
from datetime import datetime, timezone
from rclpy.parameter import Parameter
from turtlebot4_navigation.turtlebot4_navigator import (
    TurtleBot4Directions, TurtleBot4Navigator, TaskResult)

from paho.mqtt import client as mqtt_client

#ì¢Œí‘œ
from geometry_msgs.msg import PointStamped
import tf2_ros
import tf2_geometry_msgs
import rclpy
from rclpy.duration import Duration

# ========== MQTT ì„¤ì • ==========
MQTT_CONFIG = {
    'broker': 'p021f2cb.ala.asia-southeast1.emqxsl.com',
    'port': 8883,
    'username': 'Rokey',
    'password': '1234567',
    'topic': "crack",
    'client_id': f'python-mqtt-{random.randint(0, 100)}',
    'keepalive': 60
}

# ========== ë¡œë´‡ ì„¤ì • ==========
ROBOT_CONFIG = {
    'namespace': '/robot1',  # ì‹¤ì œ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¡œ ìˆ˜ì •
    'robot_id': 'robot1',
    'initial_position': [-0.77, -0.77],
    'initial_direction': TurtleBot4Directions.NORTH,
    'waypoints': [
        ([-0.80, -0.80], TurtleBot4Directions.NORTH),
        ([-2.0, -0.77], TurtleBot4Directions.SOUTH),
        ([-1.9, -3.0], TurtleBot4Directions.SOUTH),
        ([-0.5, -2.8], TurtleBot4Directions.SOUTH),
    ],
    'spin_angle': 2 * math.pi,
    'nav_timeout': 30.0,
    'skip_docking': False  # ë„í‚¹ ê¸°ëŠ¥ í™œì„±í™” (dock_status í† í”½ ì¡´ì¬í•¨)
}

class NamespacedRobotController:
    """ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì§€ì›í•˜ëŠ” ë¡œë´‡ ë„¤ë¹„ê²Œì´ì…˜ ì»¨íŠ¸ë¡¤ëŸ¬"""
    
    def __init__(self):
        self.stop_flag = False
        self.mqtt_client = None
        self.navigator = None
        self.mqtt_connected = False
        self.navigation_active = False
        self._lock = threading.Lock()
        self.namespace = ROBOT_CONFIG['namespace']

        self.location =  ([0, 0], TurtleBot4Directions.NORTH)
        #ì¢Œí‘œ
        self.tf_buffer = None
        self.tf_listener = None
        self.tf_initialized = False
        
    def reset_stop_flag(self):
        """ì •ì§€ í”Œë˜ê·¸ë¥¼ ì•ˆì „í•˜ê²Œ ì´ˆê¸°í™”"""
        with self._lock:
            self.stop_flag = False
            print(f"ğŸ”„ [{self.namespace}] Stop flag reset: {self.stop_flag}")
    
    def set_stop_flag(self, value=True):
        """ì •ì§€ í”Œë˜ê·¸ë¥¼ ì•ˆì „í•˜ê²Œ ì„¤ì •"""
        with self._lock:
            self.stop_flag = value
            print(f"ğŸš¨ [{self.namespace}] Stop flag set to: {self.stop_flag}")
    
    def is_stopped(self):
        """í˜„ì¬ ì •ì§€ ìƒíƒœ í™•ì¸"""
        with self._lock:
            return self.stop_flag
    
    def setup_mqtt(self):
        """MQTT í´ë¼ì´ì–¸íŠ¸ ì„¤ì • ë° ì—°ê²°"""
        def on_connect(client, userdata, flags, rc):
            if rc == 0:
                print(f"âœ… [{self.namespace}] MQTT ë¸Œë¡œì»¤ ì—°ê²° ì„±ê³µ!")
                self.mqtt_connected = True
                
                # retained ë©”ì‹œì§€ í´ë¦¬ì–´
                client.publish(MQTT_CONFIG['topic'], "", retain=True)
                print(f"ğŸ§¹ [{self.namespace}] ê¸°ì¡´ retained ë©”ì‹œì§€ í´ë¦¬ì–´ ì™„ë£Œ")
                
                # í† í”½ êµ¬ë…
                client.subscribe(MQTT_CONFIG['topic'])
                print(f"ğŸ“¡ [{self.namespace}] í† í”½ êµ¬ë… ì™„ë£Œ: {MQTT_CONFIG['topic']}")
                
                # ì—°ê²° ì™„ë£Œ ë©”ì‹œì§€ ë°œì†¡
                self.publish_event("system_ready", 0, [0, 0], [0, 0])
            else:
                print(f"âŒ [{self.namespace}] MQTT ì—°ê²° ì‹¤íŒ¨, return code: {rc}")
                self.mqtt_connected = False

        def on_message(client, userdata, msg):
            try:
                payload = msg.payload.decode().strip()
                print(f"ğŸ“© [{self.namespace}] MQTT ë©”ì‹œì§€ ìˆ˜ì‹ : '{payload}' from '{msg.topic}'")
                
                # ë¹ˆ ë©”ì‹œì§€ëŠ” ë¬´ì‹œ
                if not payload:
                    print(f"ğŸ“ [{self.namespace}] ë¹ˆ ë©”ì‹œì§€ ë¬´ì‹œ (retained í´ë¦¬ì–´)")
                    return
                
                # ì •ì§€/ì‹œì‘ ëª…ë ¹ ì²˜ë¦¬
                if payload == "1":
                    print(f"ğŸ›‘ [{self.namespace}] ì •ì§€ ëª…ë ¹ ìˆ˜ì‹ ë¨!")
                    self.set_stop_flag(True)
                elif payload == "0":
                    print(f"â–¶ï¸ [{self.namespace}] ì¬ì‹œì‘ ëª…ë ¹ ìˆ˜ì‹ ë¨!")
                    self.reset_stop_flag()
                
                #ì¢Œí‘œ
                elif json.loads(payload).get('type') == 'crack':
                    print('Crack detected - processing location')
                    self.location = (json.loads(payload).get('location'),TurtleBot4Directions.NORTH)
                    print(self.location)
                    self.set_stop_flag(True)
                    
                    

                else:
                    print(f"â“ [{self.namespace}] ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹: {payload}")
                    
            except Exception as e:
                print(f"âŒ [{self.namespace}] MQTT ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")

        def on_disconnect(client, userdata, rc):
            print(f"ğŸ”Œ [{self.namespace}] MQTT ì—°ê²° ëŠì–´ì§, code: {rc}")
            self.mqtt_connected = False

        # MQTT í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
        self.mqtt_client = mqtt_client.Client(
            client_id=f"{MQTT_CONFIG['client_id']}-{ROBOT_CONFIG['robot_id']}", 
            protocol=mqtt_client.MQTTv311
        )
        
        # TLS ë° ì¸ì¦ ì„¤ì •
        self.mqtt_client.tls_set()
        self.mqtt_client.username_pw_set(
            MQTT_CONFIG['username'], 
            MQTT_CONFIG['password']
        )
        
        # ì½œë°± ì„¤ì •
        self.mqtt_client.on_connect = on_connect
        self.mqtt_client.on_message = on_message
        self.mqtt_client.on_disconnect = on_disconnect
        
        # ì—°ê²° ì‹œë„
        try:
            print(f"ğŸ”„ [{self.namespace}] MQTT ë¸Œë¡œì»¤ ì—°ê²° ì‹œë„ ì¤‘...")
            self.mqtt_client.connect(
                MQTT_CONFIG['broker'], 
                MQTT_CONFIG['port'], 
                MQTT_CONFIG['keepalive']
            )
            self.mqtt_client.loop_start()
            
            # ì—°ê²° ëŒ€ê¸° (ìµœëŒ€ 5ì´ˆ)
            for i in range(50):
                if self.mqtt_connected:
                    break
                time.sleep(0.1)
            
            if not self.mqtt_connected:
                print(f"âš ï¸ [{self.namespace}] MQTT ì—°ê²° ì‹œê°„ ì´ˆê³¼, ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ê³„ì†")
                
        except Exception as e:
            print(f"âŒ [{self.namespace}] MQTT ì—°ê²° ì˜¤ë¥˜: {e}")
            print(f"âš ï¸ [{self.namespace}] MQTT ì—†ì´ ê³„ì† ì§„í–‰")
    
    def publish_event(self, event_type, waypoint_index, robot_pos, target_pos):
        """MQTT ì´ë²¤íŠ¸ ë°œí–‰"""
        if not self.mqtt_connected or not self.mqtt_client:
            print(f"ğŸ“¤ [{self.namespace}] MQTT ë¯¸ì—°ê²° - ì´ë²¤íŠ¸ ìŠ¤í‚µ: {event_type}")
            return
        
        try:
            msg = {
                "robot_id": ROBOT_CONFIG['robot_id'],
                "namespace": self.namespace,
                "event": event_type,
                "waypoint": waypoint_index,
                "robot_position": robot_pos,
                "event_position": target_pos,
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            
            result = self.mqtt_client.publish(MQTT_CONFIG['topic'], json.dumps(msg))
            if result.rc == mqtt_client.MQTT_ERR_SUCCESS:
                print(f"ğŸ“¤ [{self.namespace}] MQTT ì´ë²¤íŠ¸ ë°œí–‰ ì„±ê³µ: {event_type}")
            else:
                print(f"ğŸ“¤ [{self.namespace}] MQTT ì´ë²¤íŠ¸ ë°œí–‰ ì‹¤íŒ¨: {event_type}, rc={result.rc}")
                
        except Exception as e:
            print(f"âŒ [{self.namespace}] MQTT ë°œí–‰ ì˜¤ë¥˜: {e}")
    
    def check_docking_support(self):
        """ë„í‚¹ ê¸°ëŠ¥ ì§€ì› ì—¬ë¶€ í™•ì¸"""
        try:
            # ë„í‚¹ ê´€ë ¨ í† í”½ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
            # ì´ê²ƒì€ ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ì²´í¬ê°€ í•„ìš”í•˜ì§€ë§Œ, ê°„ë‹¨íˆ ì‹œë„í•´ë´„
            status = self.navigator.getDockedStatus()
            print(f"âœ… [{self.namespace}] ë„í‚¹ ê¸°ëŠ¥ ì§€ì›ë¨")
            return True
        except Exception as e:
            print(f"âš ï¸ [{self.namespace}] ë„í‚¹ ê¸°ëŠ¥ ì§€ì›ë˜ì§€ ì•ŠìŒ: {e}")
            return False
    
    def setup_navigation(self):
        """ë„¤ë¹„ê²Œì´ì…˜ ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
        print(f"ğŸ¤– [{self.namespace}] ROS2 ë…¸ë“œ ì´ˆê¸°í™” ì¤‘...")
        
        # ROS2 ì´ˆê¸°í™” (ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ê³ ë ¤)
        rclpy.init()
        
        #ì¢Œí‘œ
        # TF2 ì´ˆê¸°í™”
        try:
            self.tf_buffer = tf2_ros.Buffer()
            self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self.navigator)
            time.sleep(1.0)  # TF íŠ¸ë¦¬ ì•ˆì •í™” ëŒ€ê¸°
            self.tf_initialized = True
            print(f"âœ… TF2 ì´ˆê¸°í™” ì™„ë£Œ")
        except Exception as e:
            print(f"âš ï¸ TF2 ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.tf_initialized = False

        # TurtleBot4Navigator ì´ˆê¸°í™” (ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì§€ì›)
        self.navigator = TurtleBot4Navigator(namespace='robot1')  # ìŠ¬ë˜ì‹œ ì—†ì´
        print(f"ğŸ—ºï¸ [{self.namespace}] TurtleBot4 Navigator ì´ˆê¸°í™” ì™„ë£Œ")
        
        # ë„í‚¹ ê¸°ëŠ¥ í™•ì¸ ë° ì²˜ë¦¬
        if not ROBOT_CONFIG['skip_docking']:
            docking_supported = self.check_docking_support()
            if docking_supported:
                if not self.ensure_docking():
                    print(f"âš ï¸ [{self.namespace}] ë„í‚¹ ì‹¤íŒ¨í•˜ì§€ë§Œ ê³„ì† ì§„í–‰")
        else:
            print(f"â­ï¸ [{self.namespace}] ë„í‚¹ ê¸°ëŠ¥ ìŠ¤í‚µë¨")
        
        # ì´ˆê¸° í¬ì¦ˆ ì„¤ì •
        print(f"ğŸ“ [{self.namespace}] ì´ˆê¸° í¬ì¦ˆ ì„¤ì • ì¤‘...")
        initial_pose = self.navigator.getPoseStamped(
            ROBOT_CONFIG['initial_position'], 
            ROBOT_CONFIG['initial_direction']
        )
        self.navigator.setInitialPose(initial_pose)
        
        # Nav2 í™œì„±í™” ëŒ€ê¸°
        print(f"ğŸ—ºï¸ [{self.namespace}] Nav2 ì‹œìŠ¤í…œ í™œì„±í™” ëŒ€ê¸° ì¤‘...")
        self.navigator.waitUntilNav2Active()
        
        # ì´ˆê¸°í™” ì™„ë£Œ ëŒ€ê¸°
        print(f"â±ï¸ [{self.namespace}] ì‹œìŠ¤í…œ ì•ˆì •í™” ëŒ€ê¸°...")
        time.sleep(3.0)
        
        self.navigation_active = True
        print(f"âœ… [{self.namespace}] ë„¤ë¹„ê²Œì´ì…˜ ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!")
        return True
    
    def ensure_docking(self):
        """ë„í‚¹ ìƒíƒœ í™•ì¸ ë° ë³´ì¥ (ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë²„ì „)"""
        print(f"ğŸ”Œ [{self.namespace}] ë„í‚¹ ìƒíƒœ í™•ì¸ ì¤‘...")
        
        try:
            if self.navigator.getDockedStatus():
                print(f"âœ… [{self.namespace}] ë¡œë´‡ì´ ì´ë¯¸ ë„í‚¹ë¨")
                return True
            
            print(f"ğŸ”Œ [{self.namespace}] ë¡œë´‡ì´ ë„í‚¹ë˜ì§€ ì•ŠìŒ - ë„í‚¹ ì‹œë„")
            self.navigator.dock()
            
            # ë„í‚¹ ì™„ë£Œ ëŒ€ê¸°
            timeout_counter = 0
            while not self.navigator.getDockedStatus() and timeout_counter < 30:
                time.sleep(1)
                timeout_counter += 1
                if self.is_stopped():
                    print(f"ğŸš« [{self.namespace}] ë„í‚¹ ì¤‘ ì •ì§€ ëª…ë ¹ ìˆ˜ì‹ ")
                    return False
            
            if self.navigator.getDockedStatus():
                print(f"âœ… [{self.namespace}] ë„í‚¹ ì™„ë£Œ!")
                return True
            else:
                print(f"âš ï¸ [{self.namespace}] ë„í‚¹ ì‹¤íŒ¨")
                return False
                
        except Exception as e:
            print(f"âš ï¸ [{self.namespace}] ë„í‚¹ ìƒíƒœ í™•ì¸ ì˜¤ë¥˜: {e}")
            return False
    
    def ensure_undocking(self):
        """ì–¸ë„í‚¹ í™•ì¸ ë° ë³´ì¥ (ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë²„ì „)"""
        if ROBOT_CONFIG['skip_docking']:
            print(f"â­ï¸ [{self.namespace}] ì–¸ë„í‚¹ ìŠ¤í‚µë¨")
            return True
            
        print(f"ğŸš€ [{self.namespace}] ì–¸ë„í‚¹ ìƒíƒœ í™•ì¸ ì¤‘...")
        
        try:
            if self.navigator.getDockedStatus():
                print(f"ğŸš€ [{self.namespace}] ë„í‚¹ ìƒíƒœì—ì„œ ì–¸ë„í‚¹ ì‹œì‘...")
                self.navigator.undock()
                
                # ì–¸ë„í‚¹ ì™„ë£Œ ëŒ€ê¸°
                timeout_counter = 0
                while self.navigator.getDockedStatus() and timeout_counter < 20:
                    time.sleep(1)
                    timeout_counter += 1
                    if self.is_stopped():
                        print(f"ğŸš« [{self.namespace}] ì–¸ë„í‚¹ ì¤‘ ì •ì§€ ëª…ë ¹ ìˆ˜ì‹ ")
                        return False
                
                if not self.navigator.getDockedStatus():
                    print(f"âœ… [{self.namespace}] ì–¸ë„í‚¹ ì™„ë£Œ!")
                else:
                    print(f"âš ï¸ [{self.namespace}] ì–¸ë„í‚¹ ì‹¤íŒ¨")
            else:
                print(f"âœ… [{self.namespace}] ë¡œë´‡ì´ ì´ë¯¸ ì–¸ë„í‚¹ë¨")
            
            # ì–¸ë„í‚¹ í›„ ì•ˆì •í™” ëŒ€ê¸°
            print(f"â±ï¸ [{self.namespace}] ì–¸ë„í‚¹ í›„ ì‹œìŠ¤í…œ ì•ˆì •í™” ëŒ€ê¸°...")
            time.sleep(2.0)
            return True
            
        except Exception as e:
            print(f"âš ï¸ [{self.namespace}] ì–¸ë„í‚¹ ì˜¤ë¥˜: {e}")
            return False
    
    def wait_for_task_completion(self, task_description="", timeout=None):
        """ì‘ì—… ì™„ë£Œ ëŒ€ê¸° (ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë²„ì „)"""
        if timeout is None:
            timeout = ROBOT_CONFIG['nav_timeout']
        
        start_time = time.time()
        
        while not self.navigator.isTaskComplete():
            # ì •ì§€ ëª…ë ¹ í™•ì¸
            if self.is_stopped():
                print(f"ğŸš¨ [{self.namespace}] ì •ì§€ ëª…ë ¹ìœ¼ë¡œ ì¸í•œ ì‘ì—… ì·¨ì†Œ: {task_description}")
                self.navigator.cancelTask()
                return False
            
            # íƒ€ì„ì•„ì›ƒ í™•ì¸
            if time.time() - start_time > timeout:
                print(f"â° [{self.namespace}] ì‘ì—… íƒ€ì„ì•„ì›ƒ: {task_description}")
                self.navigator.cancelTask()
                return False
            
            # ROS2 ìŠ¤í•€
            rclpy.spin_once(self.navigator, timeout_sec=0.1)
        
        # ê²°ê³¼ í™•ì¸
        result = self.navigator.getResult()
        if result == TaskResult.SUCCEEDED:
            print(f"âœ… [{self.namespace}] ì‘ì—… ì„±ê³µ: {task_description}")
            return True
        else:
            print(f"âŒ [{self.namespace}] ì‘ì—… ì‹¤íŒ¨: {task_description}, ê²°ê³¼={result}")
            return False
    
    def get_current_position(self):
        """í˜„ì¬ ë¡œë´‡ ìœ„ì¹˜ ë°˜í™˜"""
        try:
            pose = self.navigator.getCurrentPose()
            if pose:
                return [pose.pose.position.x, pose.pose.position.y]
            else:
                return [0.0, 0.0]
        except Exception as e:
            print(f"âš ï¸ [{self.namespace}] í˜„ì¬ ìœ„ì¹˜ íšë“ ì‹¤íŒ¨: {e}")
            return [0.0, 0.0]
    
    def navigate_to_waypoint(self, waypoint_index, position, direction):
        """íŠ¹ì • ì›¨ì´í¬ì¸íŠ¸ë¡œ ì´ë™"""
        if self.is_stopped():
            return False
        
        print(f"ğŸ¯ [{self.namespace}] [{waypoint_index}/{len(ROBOT_CONFIG['waypoints'])}] ì›¨ì´í¬ì¸íŠ¸ ì´ë™: {position}")
        
        # ëª©í‘œ í¬ì¦ˆ ìƒì„±
        goal_pose = self.navigator.getPoseStamped(position, direction)
        
        # ì´ë™ ì‹œì‘
        self.navigator.goToPose(goal_pose)
        
        # ì´ë™ ì™„ë£Œ ëŒ€ê¸°
        success = self.wait_for_task_completion(f"ì›¨ì´í¬ì¸íŠ¸ {waypoint_index} ì´ë™")
        
        if success:
            robot_pos = self.get_current_position()
            self.publish_event("waypoint_arrival", waypoint_index, robot_pos, position)
            print(f"âœ… [{self.namespace}] ì›¨ì´í¬ì¸íŠ¸ {waypoint_index} ë„ì°©!")
        
        return success
    
    def perform_rotation(self, waypoint_index):
        """360ë„ íšŒì „ ìˆ˜í–‰"""
        if self.is_stopped():
            return False
        
        print(f"ğŸ”„ [{self.namespace}] ì›¨ì´í¬ì¸íŠ¸ {waypoint_index}ì—ì„œ 360Â° íšŒì „ ì‹œì‘")
        
        # íšŒì „ ì‹œì‘
        self.navigator.spin(spin_dist=ROBOT_CONFIG['spin_angle'])
        
        # íšŒì „ ì™„ë£Œ ëŒ€ê¸°
        success = self.wait_for_task_completion(f"ì›¨ì´í¬ì¸íŠ¸ {waypoint_index} íšŒì „", timeout=15.0)
        
        if success:
            robot_pos = self.get_current_position()
            self.publish_event("rotation_complete", waypoint_index, robot_pos, robot_pos)
            print(f"âœ… [{self.namespace}] ì›¨ì´í¬ì¸íŠ¸ {waypoint_index} íšŒì „ ì™„ë£Œ!")
        
        return success
    
    def run_patrol_cycle(self):
        """íŒ¨íŠ¸ë¡¤ ì‚¬ì´í´ ì‹¤í–‰"""
        if not self.navigation_active:
            print(f"âŒ ë„¤ë¹„ê²Œì´ì…˜ì´ í™œì„±í™”ë˜ì§€ ì•ŠìŒ")
            return False
        
        # íŒ¨íŠ¸ë¡¤ ì‹œì‘ ì „ ì–¸ë„í‚¹ í™•ì¸
        if not self.ensure_undocking():
            print(f"âŒ ì–¸ë„í‚¹ ì‹¤íŒ¨ë¡œ íŒ¨íŠ¸ë¡¤ ì¤‘ë‹¨")
            return False
        
        cycle_count = 0
        
        try:
            while rclpy.ok() :
                cycle_count += 1
                print(f"\nğŸ”„ [{self.namespace}] === íŒ¨íŠ¸ë¡¤ ì‚¬ì´í´ {cycle_count} ì‹œì‘ ===")
                if self.is_stopped():
                    print('ã…ã…ã…ã…ã…ë¬¼ì²´ ì¢Œí‘œë¡œ ì´ë™ì¤‘')
                    self.navigate_to_waypoint(i, position, direction)
                    time.sleep(0.5)
                    self.is_stopped() == False
                
                else :
                    for i, (position, direction) in enumerate(ROBOT_CONFIG['waypoints'], start=1):
                        if self.is_stopped():
                            print(f"ğŸš« ì •ì§€ ëª…ë ¹ìœ¼ë¡œ ì¸í•œ íŒ¨íŠ¸ë¡¤ ì¤‘ë‹¨")
                            return True
                        
                        # ì›¨ì´í¬ì¸íŠ¸ë¡œ ì´ë™
                        if not self.navigate_to_waypoint(i, position, direction):
                            print(f"âŒ ì›¨ì´í¬ì¸íŠ¸ {i} ì´ë™ ì‹¤íŒ¨")
                            continue
                        
                        # 360ë„ íšŒì „
                        if not self.perform_rotation(i):
                            print(f"âŒ ì›¨ì´í¬ì¸íŠ¸ {i} íšŒì „ ì‹¤íŒ¨")
                            continue
                        
                        # ì›¨ì´í¬ì¸íŠ¸ ê°„ ì§§ì€ ëŒ€ê¸°
                        time.sleep(0.5)

                # ì‚¬ì´í´ ì™„ë£Œ ì´ë²¤íŠ¸
                robot_pos = self.get_current_position()
                self.publish_event("route_complete", cycle_count, robot_pos, robot_pos)
                print(f"âœ… íŒ¨íŠ¸ë¡¤ ì‚¬ì´í´ {cycle_count} ì™„ë£Œ!\n")
                
                # ì‚¬ì´í´ ê°„ ëŒ€ê¸°
                time.sleep(1.0)
        
        except KeyboardInterrupt:
            print(f"\nğŸ›‘ ì‚¬ìš©ì ì¤‘ë‹¨ ìš”ì²­")
            return True
        except Exception as e:
            print(f"\nâŒ íŒ¨íŠ¸ë¡¤ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return False
    
    def cleanup(self):
        """ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
        print(f"ğŸ§¹ ì‹œìŠ¤í…œ ì •ë¦¬ ì¤‘...")
        
        if self.mqtt_client:
            try:
                self.publish_event("system_shutdown", 0, [0, 0], [0, 0])
                self.mqtt_client.loop_stop()
                self.mqtt_client.disconnect()
                print(f"âœ… MQTT ì—°ê²° ì¢…ë£Œ")
            except Exception as e:
                print(f"âš ï¸ MQTT ì •ë¦¬ ì˜¤ë¥˜: {e}")
        
        if self.navigator and rclpy.ok():
            try:
                self.navigator.cancelTask()
                print(f"âœ… ë„¤ë¹„ê²Œì´ì…˜ ì‘ì—… ì·¨ì†Œ")
            except Exception as e:
                print(f"âš ï¸ ë„¤ë¹„ê²Œì´ì…˜ ì •ë¦¬ ì˜¤ë¥˜: {e}")
        
        print(f"ğŸ ì‹œìŠ¤í…œ ì •ë¦¬ ì™„ë£Œ")

def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    controller = NamespacedRobotController()
    
    try:
        print(f"ğŸš€ === TurtleBot4 íŒ¨íŠ¸ë¡¤ ì‹œìŠ¤í…œ ì‹œì‘ [{ROBOT_CONFIG['namespace']}] ===\n")
        
        # 1. MQTT ì„¤ì •
        controller.setup_mqtt()
        time.sleep(1.0)  # MQTT ì•ˆì •í™” ëŒ€ê¸°
        
        # 2. ë„¤ë¹„ê²Œì´ì…˜ ì„¤ì •
        if not controller.setup_navigation():
            print(f"âŒ [{ROBOT_CONFIG['namespace']}] ë„¤ë¹„ê²Œì´ì…˜ ì´ˆê¸°í™” ì‹¤íŒ¨")
            return
        
        # 3. íŒ¨íŠ¸ë¡¤ ì‹¤í–‰
        print(f"ğŸ¯ [{ROBOT_CONFIG['namespace']}] íŒ¨íŠ¸ë¡¤ ì‹œì‘!")
        controller.run_patrol_cycle()
        
    except Exception as e:
        print(f"âŒ [{ROBOT_CONFIG['namespace']}] ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}")
    finally:
        controller.cleanup()
        print(f"ğŸ‘‹ [{ROBOT_CONFIG['namespace']}] í”„ë¡œê·¸ë¨ ì¢…ë£Œ")

if __name__ == '__main__':
    main()
